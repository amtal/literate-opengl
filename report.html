<!-- this file was generated automatically by noweave; better not edit it-->
<ul>
<li><a href="#NW0-2f73Kx-1"><i>&lt;Cam helper functions&gt;</i></a>: <a href="#NWD0-6">U1</a>, <a href="#NW0-2f73Kx-1">D2</a>
<li><a href="#NWD0-M"><i>&lt;city.c&gt;</i></a>: <a href="#NWD0-M">D1</a>
<li><a href="#NWD0-K"><i>&lt;city.h&gt;</i></a>: <a href="#NWD0-K">D1</a>, <a href="#NWD0-L">D2</a>
<li><a href="#NWD0-T"><i>&lt;Copyright&gt;</i></a>: <a href="#NWD0-1">U1</a>, <a href="#NWD0-B">U2</a>, <a href="#NWD0-C">U3</a>, <a href="#NWD0-D">U4</a>, <a href="#NWD0-I">U5</a>, <a href="#NW0-3OKV3b-1">U6</a>, <a href="#NW0-mDFBQ-1">U7</a>, <a href="#NWD0-K">U8</a>, <a href="#NWD0-R">U9</a>, <a href="#NWD0-S">U10</a>, <a href="#NWD0-T">D11</a>
<li><a href="#NWD0-E"><i>&lt;Count and allocate memory for vertices triangles and textures&gt;</i></a>: <a href="#NWD0-D">U1</a>, <a href="#NWD0-E">D2</a>
<li><a href="#NW0-3j0qiB-1"><i>&lt;Draw a model&gt;</i></a>: <a href="#NWD0-8">U1</a>, <a href="#NW0-3j0qiB-1">D2</a>
<li><a href="#NWD0-F"><i>&lt;File IO utility functions&gt;</i></a>: <a href="#NWD0-D">U1</a>, <a href="#NWD0-F">D2</a>, <a href="#NWD0-G">D3</a>
<li><a href="#NWD0-O"><i>&lt;Freeing a city&gt;</i></a>: <a href="#NWD0-M">U1</a>, <a href="#NWD0-O">D2</a>
<li><a href="#NW0-3C82A9-1"><i>&lt;Global cleanup&gt;</i></a>: <a href="#NWD0-1">U1</a>, <a href="#NW0-3C82A9-1">D2</a>, <a href="#NW0-3C82A9-2">D3</a>
<li><a href="#NW0-2ob9xm-1"><i>&lt;Global initialization&gt;</i></a>: <a href="#NWD0-1">U1</a>, <a href="#NW0-2ob9xm-1">D2</a>, <a href="#NWD0-4">D3</a>, <a href="#NWD0-9">D4</a>, <a href="#NW0-2ob9xm-4">D5</a>, <a href="#NW0-2ob9xm-5">D6</a>
<li><a href="#NWD0-3"><i>&lt;Globals&gt;</i></a>: <a href="#NWD0-1">U1</a>, <a href="#NWD0-3">D2</a>, <a href="#NW0-3PmW1A-2">D3</a>, <a href="#NW0-3PmW1A-3">D4</a>, <a href="#NWD0-Q">D5</a>
<li><a href="#NW0-1FaN2o-1"><i>&lt;GLUT functions&gt;</i></a>: <a href="#NWD0-1">U1</a>, <a href="#NW0-1FaN2o-1">D2</a>, <a href="#NWD0-5">D3</a>, <a href="#NWD0-6">D4</a>, <a href="#NW0-1FaN2o-4">D5</a>, <a href="#NWD0-8">D6</a>
<li><a href="#NWD0-D"><i>&lt;load.c&gt;</i></a>: <a href="#NWD0-D">D1</a>
<li><a href="#NWD0-C"><i>&lt;load.h&gt;</i></a>: <a href="#NWD0-C">D1</a>
<li><a href="#NWD0-N"><i>&lt;Loading a city&gt;</i></a>: <a href="#NWD0-M">U1</a>, <a href="#NWD0-N">D2</a>
<li><a href="#NWD0-2"><i>&lt;Main includes&gt;</i></a>: <a href="#NWD0-1">U1</a>, <a href="#NWD0-2">D2</a>, <a href="#NWD0-7">D3</a>, <a href="#NWD0-A">D4</a>, <a href="#NWD0-P">D5</a>
<li><a href="#NWD0-1"><i>&lt;main.c&gt;</i></a>: <a href="#NWD0-1">D1</a>
<li><a href="#NWD0-B"><i>&lt;model.h&gt;</i></a>: <a href="#NWD0-B">D1</a>
<li><a href="#NWD0-U"><i>&lt;Name definition&gt;</i></a>: <a href="#NWD0-8">U1</a>, <a href="#NWD0-U">D2</a>
<li><a href="#NWD0-H"><i>&lt;Read vertices triangles and textures&gt;</i></a>: <a href="#NWD0-D">U1</a>, <a href="#NWD0-H">D2</a>
<li><a href="#NW0-1k8F3q-1"><i>&lt;Render city&gt;</i></a>: <a href="#NWD0-8">U1</a>, <a href="#NW0-1k8F3q-1">D2</a>
<li><a href="#NW0-3OKV3b-1"><i>&lt;render.c&gt;</i></a>: <a href="#NW0-3OKV3b-1">D1</a>
<li><a href="#NWD0-I"><i>&lt;render.h&gt;</i></a>: <a href="#NWD0-I">D1</a>
<li><a href="#NWD0-V"><i>&lt;Test render functions&gt;</i></a>: <a href="#NWD0-8">U1</a>, <a href="#NWD0-V">D2</a>
<li><a href="#NW0-mDFBQ-1"><i>&lt;texture.c&gt;</i></a>: <a href="#NW0-mDFBQ-1">D1</a>
<li><a href="#NWD0-J"><i>&lt;texture.h&gt;</i></a>: <a href="#NWD0-J">D1</a>
<li><a href="#NWD0-S"><i>&lt;vec.c&gt;</i></a>: <a href="#NWD0-S">D1</a>
<li><a href="#NWD0-R"><i>&lt;vec.h&gt;</i></a>: <a href="#NWD0-R">D1</a>
</ul>





<p>
<h1>EECE 478: Assignment 1</h1>
<address>Alex Kropivny</address>

<!--title goes here--><p>
<p>
<tableofcontents>
<b>[Table of contents]</b>
</tableofcontents>
<p>


<p>
<h2>Introduction</h2>
<p>

Assignment 1 is mostly a straightforward refresher of general C/C++ programming techniques and basic OpenGL/GLUT API use. 
<p>
To make things interesting, use unfamiliar technology, and provide well-documented code that's easy to understand and mark I have chosen to document my C code in a literate programming style, as described by Donald Knuth in 1984. If this goes well, the result should be a document describing the implementation of my C program with extreme clarity and detail.
<p>
<h3>Usage Instructions</h3>
<p>
The application controls are simple. With the mouse, use left click to rotate the camera and right click to move the model around. Arrow keys allow you to zoom and rotate the model, space bar switches between different models, and Q or ESC exit the program.
<p>
<h3>Literate Programming</h3>
<p>
This uncommon technology deserves a brief explanation. Literate programming combines natural language descriptions of a program (documentation) alongside the actual code of the program (implementation) in the same file. A preprocessor then takes this file, and from it produces two separate things; nicely formatted documentation, and the actual compileable code.
<p>
The natural language descriptions do what comments mostly fail to: provide a clear view of the programmer's train of thought. This is further assisted by a very simple macro system used by the LP preprocessor, which allows the programmer to structure code according to how a human thinks, rather than what the C compiler requires. (This is what makes it literate 'programming', rather than just fancy documentation.)
<p>
What this all boils down to are two programs that 'tangle' and 'weave' a .nw file (I use a LP preprocessor called noweb) into a bunch of .c and .h files and a .tex file, respectively. The .nw file is formatted into code and documentation chunks. Documentation chunks are unnamed, code chunks are named and can be inserted within other code chunks like include files in C.
<p>

<h3>Modular Design</h3>
<p>
iterate programming helps write better code, but does not do so automatically. One problem it runs into is clear from the start, by the presence of the 'web' analogy. On a small scope it's normal for complex code to form a small web, but with larger scopes it is a nightmare scenario and should be avoided at all costs.
<p>
Thus, standard design techniques still apply. The first concern is factoring the project into modules and their interdependencies.
<p>
Since it's a fairly small project, Figure <a href="#fig:moddep">[-&gt;]</a> says it all. Since we're dealing with C, the individual modules are .c files with interfaces defined in .h files.
<p>
<hr>
<b>Module dependencies</b>
<a name="fig:moddep"><b>[*]</b></a>
<blockquote>
<b>[</b>Ill-understood graphics<b>]</b>
</blockquote>
<hr>
<p>
<a name="NWD0-1">I choose 'noweb' as the literate preprocessor due to its' simplicity: the price of that simplicity is all the C code in the project will be stored in a single .nw file. This is atypical as far as programming goes, but I will give it a go. Despite everything being in one file, the code will still be split up according to the above design.</a>
<p>
<h2>GLUT Application</h2>
<p>
We'll start with a top down look at the code.
<p>
The base of the program looks familiar.
<p>
<pre><a name="NW0-1ezWyf-1" href="#NWD0-1"><dfn>&lt;main.c&gt;=</dfn></a>
<a name="NW0-1ezWyf-1-u1" href="#NWD0-T"><i>&lt;Copyright&gt;</i></a>
<a name="NW0-1ezWyf-1-u2" href="#NWD0-2"><i>&lt;Main includes&gt;</i></a>
<a name="NW0-1ezWyf-1-u3" href="#NWD0-3"><i>&lt;Globals&gt;</i></a>

<a name="NW0-1ezWyf-1-u4" href="#NW0-1FaN2o-1"><i>&lt;GLUT functions&gt;</i></a>

// registered with atexit
void <a href="#NWD0-1">cleanup</a>()
{
    <a name="NW0-1ezWyf-1-u5" href="#NW0-3C82A9-1"><i>&lt;Global cleanup&gt;</i></a>
}

int <a href="#NWD0-1">main</a>(int argc, char** argv)
{
    <a name="NW0-1ezWyf-1-u6" href="#NW0-2ob9xm-1"><i>&lt;Global initialization&gt;</i></a>
    glutMainLoop();
    return 0;
}

</pre><blockquote><br>
This code is written to a file (or else not used).<p>
Defines <a href="#NWI-cleanup"><code>cleanup</code></a>, <a href="#NWI-main"><code>main</code></a> (links are to index).<p>
</blockquote><p>

<h3><a name="NWD0-2">Boilerplate</a></h3>
<p>
Initializing and configuring GLUT and OpenGL consists of mostly boilerplate code. The interesting details are mostly hidden in other modules.
<p>
<pre><a name="NW0-1Abiqb-1" href="#NWD0-2"><dfn>&lt;Main includes&gt;=</dfn></a>
#include &lt;GL/glut.h&gt;
#include &lt;stdlib.h&gt; // exit() and atexit()
#include &lt;string.h&gt; // strlen(), used once
</pre><blockquote>Used <a href="#NWD0-1">above</a>; <a href="#NWD0-7">next</a> definition.<p>
</blockquote><p>

<pre><a name="NW0-2ob9xm-1" href="#NW0-2ob9xm-1"><dfn>&lt;Global initialization&gt;=</dfn></a>
// window creation
glutInit(&amp;argc, argv);
glutInitWindowSize(<a href="#NWD0-3">winHeight</a>, <a href="#NWD0-3">winWidth</a>);
glutInitDisplayMode(GLUT_RGB | GLUT_DOUBLE | GLUT_DEPTH);
glutCreateWindow(&quot;EECE478 Assignment 1&quot;);

// callback registration
glutDisplayFunc(<a href="#NWD0-8">display</a>);
glutReshapeFunc(<a href="#NWD0-5">reshape</a>);
glutMotionFunc(<a href="#NW0-1FaN2o-4">motion</a>); // in case I want to differentiate between buttons,
glutPassiveMotionFunc(<a href="#NW0-1FaN2o-4">motion</a>); // I'll handle press detection myself
glutMouseFunc(<a href="#NW0-1FaN2o-4">click</a>);
glutKeyboardFunc(<a href="#NW0-1FaN2o-1">keyboard</a>);
glutSpecialFunc(<a href="#NWD0-6">special_key</a>); // like glutKeyboardFunc, but handles non-ASCII keys
atexit(<a href="#NWD0-1">cleanup</a>);

</pre><blockquote>Used <a href="#NWD0-1">above</a>; <a href="#NWD0-4">next</a> definition.<p>
</blockquote><p>

<a name="NWD0-3">There's a bunch of mutable state that must be tracked, mostly for UI or option purposes.</a>
<p><pre><a name="NW0-3PmW1A-1" href="#NWD0-3"><dfn>&lt;Globals&gt;=</dfn></a>
// dimensions
int <a href="#NWD0-3">winHeight</a> = 480;
int <a href="#NWD0-3">winWidth</a> = 640;
// mouse state
int <a href="#NWD0-3">lmbDown</a>=0, rmbDown=0, mouseX, mouseY;
// trackball state
vec3 trackballPoint = {0,0,0};
// option states
int <a href="#NWD0-3">what_to_draw</a> = 0;
#define <a href="#NWD0-3">DRAW_TEAPOT</a> 0
#define <a href="#NWD0-3">DRAW_MODEL</a> 1
#define <a href="#NWD0-3">DRAW_CUBE</a> 2
#define <a href="#NWD0-3">DRAW_AXES</a> 3
int <a href="#NWD0-3">do_lighting</a> = 1;
int <a href="#NWD0-3">do_textures</a> = 1;
</pre><blockquote>Used <a href="#NWD0-1">above</a>; <a href="#NW0-3PmW1A-2">next</a> definition.<p>
Defines <a href="#NWI-do_lighting"><code>do_lighting</code></a>, <a href="#NWI-do_textures"><code>do_textures</code></a>, <a href="#NWI-DRAW_AXES"><code>DRAW_AXES</code></a>, <a href="#NWI-DRAW_CUBE"><code>DRAW_CUBE</code></a>, <a href="#NWI-DRAW_MODEL"><code>DRAW_MODEL</code></a>, <a href="#NWI-DRAW_TEAPOT"><code>DRAW_TEAPOT</code></a>, <a href="#NWI-lmbDown"><code>lmbDown</code></a>, <a href="#NWI-what_to_draw"><code>what_to_draw</code></a>, <a href="#NWI-winHeight"><code>winHeight</code></a>, <a href="#NWI-winWidth"><code>winWidth</code></a> (links are to index).<p>
</blockquote><p>


<a name="NWD0-4">Actual graphics options come next.</a>
<p>
<pre><a name="NW0-2ob9xm-2" href="#NW0-2ob9xm-1"><dfn>&lt;Global initialization&gt;+=</dfn></a>
// graphics configuration
glEnable(GL_DEPTH_TEST); 
glEnable(GL_CULL_FACE);
glDepthMask(GL_TRUE);
glCullFace(GL_BACK);

glShadeModel(GL_SMOOTH);
</pre><blockquote>Used <a href="#NWD0-1">above</a>; <a href="#NW0-2ob9xm-1">previous</a> and <a href="#NWD0-9">next</a> definitions.<p>
</blockquote><p>



<pre><a name="NW0-1FaN2o-1" href="#NW0-1FaN2o-1"><dfn>&lt;GLUT functions&gt;=</dfn></a>
void <a href="#NW0-1FaN2o-1">keyboard</a>(unsigned char key, int x, int y)
{
    switch(key) {
    case 'Q':
    case 'q':
    case 0x1b: // exit with ESC|q|Q
        exit(0);
        break;
    case ' ': // toggle <a href="#NWD0-B">model</a> to draw with SPACE
        <a href="#NWD0-3">what_to_draw</a> = <a href="#NWD0-3">what_to_draw</a>==<a href="#NWD0-3">DRAW_AXES</a> ? 0 : <a href="#NWD0-3">what_to_draw</a>+1;
        glutPostRedisplay();
        break;
    case 'l':
    case 'L': // doesn't work for more than 1 frame for some reason
        <a href="#NWD0-3">do_lighting</a> = !<a href="#NWD0-3">do_lighting</a>;
        if (<a href="#NWD0-3">do_lighting</a>) 
            glEnable(GL_LIGHTING);
        else
            glDisable(GL_LIGHTING);
        glutPostRedisplay();
        break;
    case 't':
    case 'T':
        <a href="#NWD0-3">do_textures</a> = !<a href="#NWD0-3">do_textures</a>;
        glutPostRedisplay();
        break;
    }
};

</pre><blockquote>Used <a href="#NWD0-1">above</a>; <a href="#NWD0-5">next</a> definition.<p>
Defines <a href="#NWI-keyboard"><code>keyboard</code></a> (links are to index).<p>
</blockquote><p>

<h3><a name="NWD0-5">Camera Controls</a></h3>
<p>
Rather than track an actual camera position and orientation, then update the projection matrix to match them, here it's sufficient to use the projection matrix to keep track of all state. This greatly simplifies the code.
<p>
Rotations are always done about the origin, and aren't affected by camera translations. This interface is limited, but very easy to use.
<p>
The coordinate system treats positive y axis as 'up', and positive z axis (initially) pointed away from the user.
<p>
<pre><a name="NW0-1FaN2o-2" href="#NW0-1FaN2o-1"><dfn>&lt;GLUT functions&gt;+=</dfn></a>
void <a href="#NWD0-5">reshape</a>(GLint width, GLint height)
{
    glViewport(0,0,width,height);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluPerspective( 90.0 // field of view
                  , (float)width/height // aspect ratio
                  , 0.1  // near clipping plane
                  , 1000 // far clipping plane
                  );
    // set camera TODO
    gluLookAt(-10, 10, -10, // eye position
              0, 0, 0,  // focus position
              0, 1, 0);  // 'up' vector
    glMatrixMode(GL_MODELVIEW);
    <a href="#NWD0-3">winHeight</a> = height;
    <a href="#NWD0-3">winWidth</a> = width;
};

</pre><blockquote>Used <a href="#NWD0-1">above</a>; <a href="#NW0-1FaN2o-1">previous</a> and <a href="#NWD0-6">next</a> definitions.<p>
Defines <a href="#NWI-reshape"><code>reshape</code></a> (links are to index).<p>
</blockquote><p>

<a name="NWD0-6">With a confusing name, glutSpecialFunc() is equivalent to the glutKeyboardFunc() but covers non-ASCII keys. With it, and glutGetModifiers() all forms of keyboard input should be covered.</a>
<p>
<pre><a name="NW0-1FaN2o-3" href="#NW0-1FaN2o-1"><dfn>&lt;GLUT functions&gt;+=</dfn></a>

<a name="NW0-1FaN2o-3-u1" href="#NW0-2f73Kx-1"><i>&lt;Cam helper functions&gt;</i></a>

void <a href="#NWD0-6">special_key</a>(int key, int x, int y)
{
    switch(key) {
    // rotate and zoom with the ARROW KEYS
    case GLUT_KEY_UP:
        <a href="#NW0-2f73Kx-1">zoomCam</a>(1.1);
    break;
    case GLUT_KEY_DOWN:
        <a href="#NW0-2f73Kx-1">zoomCam</a>(0.9);
    break;
    case GLUT_KEY_LEFT:
        <a href="#NW0-2f73Kx-1">rotCam</a>(-5); 
    break;
    case GLUT_KEY_RIGHT:
        <a href="#NW0-2f73Kx-1">rotCam</a>(5); 
    break;
    }
};
</pre><blockquote>Used <a href="#NWD0-1">above</a>; <a href="#NWD0-5">previous</a> and <a href="#NW0-1FaN2o-4">next</a> definitions.<p>
Defines <a href="#NWI-special_key"><code>special_key</code></a> (links are to index).<p>
</blockquote><p>

<pre><a name="NW0-2f73Kx-1" href="#NW0-2f73Kx-1"><dfn>&lt;Cam helper functions&gt;=</dfn></a>
void <a href="#NW0-2f73Kx-1">zoomCam</a>(float <a href="#NW0-1k8F3q-1">f</a>) 
{
    // Zooming the camera is just zooming about the origin, just need to
    // make sure the right matrix is set.
    glMatrixMode(GL_PROJECTION);
    glScalef(<a href="#NW0-1k8F3q-1">f</a>,<a href="#NW0-1k8F3q-1">f</a>,<a href="#NW0-1k8F3q-1">f</a>);
    glMatrixMode(GL_MODELVIEW);
    glutPostRedisplay();
}

void <a href="#NW0-2f73Kx-1">rotCam</a>(float <a href="#NW0-1k8F3q-1">f</a>)
{
    // Same for rotations.
    glMatrixMode(GL_PROJECTION);
    glRotatef(<a href="#NW0-1k8F3q-1">f</a>, 0, 1, 0); // y-axis is 'up'
    glMatrixMode(GL_MODELVIEW);
    glutPostRedisplay();
}
</pre><blockquote>Used <a href="#NWD0-6">above</a>.<p>
Defines <a href="#NWI-rotCam"><code>rotCam</code></a>, <a href="#NWI-zoomCam"><code>zoomCam</code></a> (links are to index).<p>
</blockquote><p>

<a name="NWD0-7">The current 'trackball' mouse-rotation code is a bit simplistic and doesn't work as it ideally should. Rotations are always done about the same axes, even when previous rotations have made the apparent axes of rotation change.</a>
<p>
As well, the code is too complex and independant to belong in main.c: it should be moved out into a separate camera module. Ideally, I'd like to figure out the whole quaternion business before deciding which parts to move out and which parts to leave, though.
<p>
<pre><a name="NW0-1Abiqb-2" href="#NWD0-2"><dfn>&lt;Main includes&gt;+=</dfn></a>
#include &lt;math.h&gt;
#include &lt;stdio.h&gt;
#include &quot;vec.h&quot;
</pre><blockquote>Used <a href="#NWD0-1">above</a>; <a href="#NWD0-2">previous</a> and <a href="#NWD0-A">next</a> definitions.<p>
</blockquote><p>

<pre><a name="NW0-1FaN2o-4" href="#NW0-1FaN2o-1"><dfn>&lt;GLUT functions&gt;+=</dfn></a>
// state tracking, no side effects
void <a href="#NW0-1FaN2o-4">click</a>(int button, int state, int x, int y)
{
    switch(button) {
    case GLUT_LEFT_BUTTON:
        <a href="#NWD0-3">lmbDown</a> = state==GLUT_DOWN;
    break;
    case GLUT_RIGHT_BUTTON:
        rmbDown = state==GLUT_DOWN;
    break;
    }
};

#define <a href="#NW0-1FaN2o-4">MIN</a>(a, b) (a)&lt;(b) ? (a) : (b) 

#define <a href="#NW0-1FaN2o-4">PI</a> 3.14159265
#define <a href="#NW0-1FaN2o-4">RAD_TO_DEG</a> 180/<a href="#NW0-1FaN2o-4">PI</a>

void <a href="#NW0-1FaN2o-4">motion</a>(int x, int y)
{
    // Left mouse button rotates around the origin.
    if (<a href="#NWD0-3">lmbDown</a>) {
        // find this point on a virtual sphere &quot;trackball&quot;
        //
        // first convert sx and sy from (0..width,0..height) to 
        // (-1..1,-1..1) range
        //
        // to ignore aspect ratio, scale factor is identical for x and y
        float scale = (float)(<a href="#NW0-1FaN2o-4">MIN</a>(<a href="#NWD0-3">winWidth</a>,<a href="#NWD0-3">winHeight</a>)/2);
        vec3 sph;
        sph.x = (float)x/scale-1.0;  sph.y = (float)y/scale-1.0;
        // z is calculated from x,y since they're on a unit sphere
        float tmp = (1-sph.x*sph.x-sph.y*sph.y);
        sph.z = tmp&gt;0 ? sqrt(tmp) : 0; // guard against negative sqrt()
        // the result should be a unit vector if the point is ON the sphere
        // if you <a href="#NW0-1FaN2o-4">click</a> outside it, though, it's not - so <a href="#NWD0-S">normalize</a>!
        <a href="#NWD0-S">normalize</a>(&amp;sph);
        //scale = sqrt(sph.z*sph.z+sph.x*sph.x+sph.y*sph.y);
        //sph.x = sph.x/scale; sph.y=sph.y/scale; sph.z=sph.z/scale;
        //<a href="#NWD0-E">printf</a>(&quot;Sphere: %<a href="#NW0-1k8F3q-1">f</a> %<a href="#NW0-1k8F3q-1">f</a> %<a href="#NW0-1k8F3q-1">f</a>\n&quot;, sph.x, sph.y, sph.z);
        
        // compute axis and angle of rotation relative to previous state
        float theta = <a href="#NW0-1FaN2o-4">RAD_TO_DEG</a>*acos(<a href="#NWD0-S">dot</a>(trackballPoint,sph));
        vec3 axis   = cross(trackballPoint,sph);

        // implement rotation
        // TODO: quaternionize this
        glMatrixMode(GL_PROJECTION);
        glRotatef(theta, axis.x, axis.y, axis.z);
        //<a href="#NWD0-E">printf</a>(&quot;\t\tRotate: %<a href="#NW0-1k8F3q-1">f</a> $ %<a href="#NW0-1k8F3q-1">f</a> %<a href="#NW0-1k8F3q-1">f</a> %<a href="#NW0-1k8F3q-1">f</a>\n&quot;, theta, axis.x, axis.y, axis.z);
        glMatrixMode(GL_MODELVIEW);
        glutPostRedisplay();

        // store state
        trackballPoint = sph;
    } else {
        // store null state if button not pressed, to avoid 'jerking' on
        // first press (cross product results in rotation on (0,0,0) axis)
        vec3 noRot = {0,0,0};
        trackballPoint = noRot;
    }
    // Right mouse button moves on the X and Z axes. (Non-vertical ones.)
    // The origin of the camera's rotations stays the same.
    if (rmbDown) {
        glMatrixMode(GL_PROJECTION);
        glTranslatef((float)(mouseX-x)/10,0,(float)(mouseY-y)/10);
        glMatrixMode(GL_MODELVIEW);
        glutPostRedisplay();
    }

    // keep track of last state for delta calculations
    mouseX = x; mouseY = y;
}
</pre><blockquote>Used <a href="#NWD0-1">above</a>; <a href="#NWD0-6">previous</a> and <a href="#NWD0-8">next</a> definitions.<p>
Defines <a href="#NWI-click"><code>click</code></a>, <a href="#NWI-MIN"><code>MIN</code></a>, <a href="#NWI-motion"><code>motion</code></a>, <a href="#NWI-PI"><code>PI</code></a>, <a href="#NWI-RAD_TO_DEG"><code>RAD_TO_DEG</code></a> (links are to index).<p>
</blockquote><p>

<h3><a name="NWD0-8">Display</a></h3>
<p>
<pre><a name="NW0-1FaN2o-5" href="#NW0-1FaN2o-1"><dfn>&lt;GLUT functions&gt;+=</dfn></a>

<a name="NW0-1FaN2o-5-u1" href="#NWD0-V"><i>&lt;Test render functions&gt;</i></a>

void <a href="#NWD0-8">renderName</a>()
{
    <a name="NW0-1FaN2o-5-u2" href="#NWD0-U"><i>&lt;Name definition&gt;</i></a>
    glDisable(GL_LIGHTING);
    glColor3f(1,1,1);
    glMatrixMode(GL_PROJECTION);
    glPushMatrix();
    glLoadIdentity();
    glRasterPos2f((float)(<a href="#NWD0-3">winWidth</a>-8*strlen(<a href="#NWD0-U">AUTHOR</a>)*2) / <a href="#NWD0-3">winWidth</a>,
                  (float)(26-<a href="#NWD0-3">winHeight</a>) / <a href="#NWD0-3">winHeight</a>);
    //glutBitmapString(GLUT_BITMAP_8_BY_13, <a href="#NWD0-U">AUTHOR</a>);
    for (char* c=<a href="#NWD0-U">AUTHOR</a>; *c!=0; c++) {
        glutBitmapCharacter(GLUT_BITMAP_8_BY_13, *c);
    }
    glPopMatrix();
    if (<a href="#NWD0-3">do_lighting</a>) glEnable(GL_LIGHTING);
}

void <a href="#NWD0-8">display</a>(void)
{
    // clear
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    // draw
    if (acity) {
        <a name="NW0-1FaN2o-5-u3" href="#NW0-1k8F3q-1"><i>&lt;Render city&gt;</i></a>
    } else {
        switch(<a href="#NWD0-3">what_to_draw</a>) {
        case <a href="#NWD0-3">DRAW_TEAPOT</a>:
            glColor3f(0,0,1);
            glFrontFace(GL_CW); // teapot has 'wrong' normals
            glutSolidTeapot(2.5);
            glFrontFace(GL_CCW);
            break;
        case <a href="#NWD0-3">DRAW_MODEL</a>:
            <a name="NW0-1FaN2o-5-u4" href="#NW0-3j0qiB-1"><i>&lt;Draw a model&gt;</i></a>
            break;
        case <a href="#NWD0-3">DRAW_CUBE</a>:
            <a href="#NWD0-V">Cube</a>();
            break;
        case <a href="#NWD0-3">DRAW_AXES</a>:
            <a href="#NWD0-V">Axes</a>();
            break;
        }
    }
    <a href="#NWD0-8">renderName</a>();
    // flip
    glutSwapBuffers();
}



</pre><blockquote>Used <a href="#NWD0-1">above</a>; <a href="#NW0-1FaN2o-4">previous</a> definition.<p>
Defines <a href="#NWI-display"><code>display</code></a>, <a href="#NWI-renderName"><code>renderName</code></a> (links are to index).<p>
</blockquote><p>

<h3><a name="NWD0-9">Lighting</a></h3>
<p>
<pre><a name="NW0-2ob9xm-3" href="#NW0-2ob9xm-1"><dfn>&lt;Global initialization&gt;+=</dfn></a>
glEnable(GL_LIGHTING);
glEnable(GL_LIGHT0);

glLightfv(GL_LIGHT0, GL_POSITION, (GLfloat[4]){60,60,60,1.0});
glLightfv(GL_LIGHT0, GL_AMBIENT, (GLfloat[4]){0.5, 0.5, 1.0, 0.6});
glLightfv(GL_LIGHT0, GL_DIFFUSE, (GLfloat[4]){0.5, 0.5, 1.0, 1.0});
glLightfv(GL_LIGHT0, GL_SPECULAR, (GLfloat[4]){1.0, 1.0, 1.0, 1.0});

glLightModelfv(GL_LIGHT_MODEL_AMBIENT, (GLfloat[4]){0.1,0.1,0.1,1.0});

</pre><blockquote>Used <a href="#NWD0-1">above</a>; <a href="#NWD0-4">previous</a> and <a href="#NW0-2ob9xm-4">next</a> definitions.<p>
</blockquote><p>

<h3><a name="NWD0-A">Model</a></h3>
<p>
All the work has been done in the load and render modules. Here, we merely use the interfaces those modules expose.
<p>
<pre><a name="NW0-1Abiqb-3" href="#NWD0-2"><dfn>&lt;Main includes&gt;+=</dfn></a>
#include &quot;load.h&quot;
#include &quot;render.h&quot;
</pre><blockquote>Used <a href="#NWD0-1">above</a>; <a href="#NWD0-7">previous</a> and <a href="#NWD0-P">next</a> definitions.<p>
</blockquote><p>
<pre><a name="NW0-3PmW1A-2" href="#NWD0-3"><dfn>&lt;Globals&gt;+=</dfn></a>
<a href="#NWD0-B">model</a>* abuilding=0;
</pre><blockquote>Used <a href="#NWD0-1">above</a>; <a href="#NWD0-3">previous</a> and <a href="#NW0-3PmW1A-3">next</a> definitions.<p>
</blockquote><p>
<pre><a name="NW0-2ob9xm-4" href="#NW0-2ob9xm-1"><dfn>&lt;Global initialization&gt;+=</dfn></a>
#define <a href="#NW0-2ob9xm-4">MODEL_FILE</a> &quot;./TechnologyEnterpriseFacility_Gregor/TechnologyEnterpriseFacility_Gregor.<a href="#NWD0-B">model</a>&quot;
abuilding = loadModel(<a href="#NW0-2ob9xm-4">MODEL_FILE</a>);
if (!abuilding) exit(1);
</pre><blockquote>Used <a href="#NWD0-1">above</a>; <a href="#NWD0-9">previous</a> and <a href="#NW0-2ob9xm-5">next</a> definitions.<p>
Defines <a href="#NWI-MODEL_FILE"><code>MODEL_FILE</code></a> (links are to index).<p>
</blockquote><p>
<pre><a name="NW0-3C82A9-1" href="#NW0-3C82A9-1"><dfn>&lt;Global cleanup&gt;=</dfn></a>
<a href="#NWD0-D">freeModel</a>(abuilding);
</pre><blockquote>Used <a href="#NWD0-1">above</a>; <a href="#NW0-3C82A9-2">next</a> definition.<p>
</blockquote><p>

<pre><a name="NW0-3j0qiB-1" href="#NW0-3j0qiB-1"><dfn>&lt;Draw a model&gt;=</dfn></a>
if (<a href="#NWD0-3">do_textures</a>) {
    glEnable(GL_TEXTURE_2D);
    <a href="#NW0-3OKV3b-1">renderModel</a>(abuilding);
    glDisable(GL_TEXTURE_2D);
} else <a href="#NW0-3OKV3b-1">renderModel</a>(abuilding);
</pre><blockquote>Used <a href="#NWD0-8">above</a>.<p>
</blockquote><p>

<h2>Model</h2>
<p>

There are two major tasks: loading the model from disk, and drawing it. Both use the same set of data structures, so there's three interdependant modules already.
<p>
The reasonable representation in C would be two separate .c files for loading and rendering (load.c, render.c, and their headers) and an additional header for the data structure declarations.
<p>
<h3><a name="NWD0-B">Data Representation</a></h3>
<p>
We'll begin with the data structure. In the file, the model structure is specified with a list of triangles that refers to a list of vertices using integer indexes. A very non-sequential access pattern, but compact and easy to implement. For small models, it'll work great without any modification.
<p>
The model is completely described by one big structure, to make loading and freeing them easy. The code is written for readability, not performance - preemptive optimization is a sin anyway.
<p>
Note that in C, structures need to have an associated typedef for this kind of code to compile. I think this makes it so you can avoid the &quot;struct&quot; keyword when defining variables with them later? You can avoid writing the name twice by only putting it at the end of the definition, but I think being able to see the name at the start makes it a lot more readable. <b>[</b>The names at the start and the end can actually be different - the first one is used in definitions that use the <code>struct</code> keyword, while the second gets used in the kind of definitions I use.<b>]</b> 
<p>
<pre><a name="NW0-3PZ18N-1" href="#NWD0-B"><dfn>&lt;model.h&gt;=</dfn></a>
<a name="NW0-3PZ18N-1-u1" href="#NWD0-T"><i>&lt;Copyright&gt;</i></a>
#ifndef <a href="#NWD0-B">_MODEL_H_</a>
#define <a href="#NWD0-B">_MODEL_H_</a>
#include &quot;vec.h&quot;
#include &quot;<a href="#NWD0-J">texture</a>.h&quot;

typedef unsigned char <a href="#NWD0-B">list_index</a>; // if we happen to need a bigger range later

typedef struct <a href="#NWD0-B">triangle</a> {
    <a href="#NWD0-B">list_index</a> a,b,c; // vertex indexes
    <a href="#NWD0-B">list_index</a> <a href="#NWD0-J">texture</a>; // hey, 4-byte alignment! :)
    vec2 tex_a,tex_b,tex_c; // <a href="#NWD0-J">texture</a> x,y coordinates for each vertex
    vec3 normal; // is this used for facing? why not clockwise order?
                 // maybe pre-calculation for lighting?
} <a href="#NWD0-B">triangle</a>;

typedef struct <a href="#NWD0-B">model</a> {
    char* name;
    // list of vertexes
    vec3* verts; <a href="#NWD0-B">list_index</a> num_verts;
    // list of triangles built on the vertexes
    <a href="#NWD0-B">triangle</a>* tris; <a href="#NWD0-B">list_index</a> num_tris;
    // list of textures
    <a href="#NWD0-J">texture</a>* tex; <a href="#NWD0-B">list_index</a> num_tex; 
    //  note: textures tend to get re-used, so this will probably just be a
    //  <a href="#NWD0-J">texture</a> id 'lookup' table, that turns the id in the <a href="#NWD0-B">model</a> file into
    //  an id used by the <a href="#NWD0-J">texture</a> loading+storage system... Or something.
    // figure it out later
} <a href="#NWD0-B">model</a>;

#endif
</pre><blockquote><br>
This code is written to a file (or else not used).<p>
Defines <a href="#NWI-_MODEL_H_"><code>_MODEL_H_</code></a>, <a href="#NWI-list_index"><code>list_index</code></a>, <a href="#NWI-model"><code>model</code></a>, <a href="#NWI-triangle"><code>triangle</code></a> (links are to index).<p>
</blockquote><p>

<h3><a name="NWD0-C">Loading</a></h3>
<p>
We've got a data type for the model! Now we need functions to operate on it. I could just use C++ and OOP, but it doesn't seem worth the effort, especially since the OpenGL interface is nowhere near OOP. 
<p>
Loading a model from a file, and freeing memory used by a loaded model are the only operations we need.
<p>

<pre><a name="NW0-lvBkV-1" href="#NWD0-C"><dfn>&lt;load.h&gt;=</dfn></a>
<a name="NW0-lvBkV-1-u1" href="#NWD0-T"><i>&lt;Copyright&gt;</i></a>
#ifndef <a href="#NWD0-C">_LOAD_H_</a>
#define <a href="#NWD0-C">_LOAD_H_</a>
#include &quot;<a href="#NWD0-B">model</a>.h&quot;

// loads a <a href="#NWD0-B">model</a> from the given filename
// on fail, prints error message to stderr and returns null
<a href="#NWD0-B">model</a>* loadModel(char* filename);

// the <a href="#NWD0-B">model</a> structure contains a bunch of dynamic size lists
void <a href="#NWD0-D">freeModel</a>(<a href="#NWD0-B">model</a>* m);

#endif
</pre><blockquote><br>
This code is written to a file (or else not used).<p>
Defines <a href="#NWI-_LOAD_H_"><code>_LOAD_H_</code></a> (links are to index).<p>
</blockquote><p>


<a name="NWD0-D">The implementation of freeModel() is straightforward. The complexity lies in loadModel(). Since the data structure uses simple lists of unknown length, we need to find how much memory the model will use before we can read it from disk. String manipulation in C can be tricky, so a few unexported helper functions are needed.</a>
<p>
<pre><a name="NW0-3QPjct-1" href="#NWD0-D"><dfn>&lt;load.c&gt;=</dfn></a>
<a name="NW0-3QPjct-1-u1" href="#NWD0-T"><i>&lt;Copyright&gt;</i></a>
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt; 
#include &lt;string.h&gt; 
#include &quot;<a href="#NWD0-B">model</a>.h&quot;

void <a href="#NWD0-D">freeModel</a>(<a href="#NWD0-B">model</a>* m) 
{
    // ensure it's not a nullpointer
    if (!m) return;
    // clean up deep pointers before removing object
    free(m-&gt;name);
    free(m-&gt;verts);
    free(m-&gt;tris);
    free(m-&gt;tex);
    free(m);
}

// We'll be using this for string processing. Note that it sets an upper limit
// on line length in the <a href="#NWD0-B">model</a> file - any longer, and bugs will occur!
#define <a href="#NWD0-D">BUFF_SIZE</a> 512

<a name="NW0-3QPjct-1-u2" href="#NWD0-F"><i>&lt;File IO utility functions&gt;</i></a>

<a href="#NWD0-B">model</a>* loadModel(char *filename) 
{
    // zero <a href="#NWD0-B">model</a> memory on allocation
    <a href="#NWD0-B">model</a>* m = (<a href="#NWD0-B">model</a>*)calloc(1, sizeof(<a href="#NWD0-B">model</a>)); 
    // general purpose string buffer for parsing
    char s[<a href="#NWD0-D">BUFF_SIZE</a>]; s[0]=0; 
    // figure out what folder the <a href="#NWD0-B">model</a>+textures are in
    char filepath[<a href="#NWD0-D">BUFF_SIZE</a>];
    strcpy(filepath,filename); 
    for (int i=strlen(filepath); 1; i--) {
        if (filepath[i]=='/') {
            filepath[i+1]=0;
            break;
        }
        if (i==0) {
            strcpy(filepath,&quot;./&quot;);
            break;
        }
    }
    <a href="#NWD0-E">printf</a>(&quot;Loading [%s]...\n&quot;, filename);
    // try to open the file, handling errors
    FILE* <a href="#NW0-1k8F3q-1">f</a> = fopen(filename, &quot;rb&quot;);
    if (!<a href="#NW0-1k8F3q-1">f</a>) {perror(&quot;loadModel() error:&quot;); return NULL;}
    <a name="NW0-3QPjct-1-u3" href="#NWD0-E"><i>&lt;Count and allocate memory for vertices triangles and textures&gt;</i></a>
    <a name="NW0-3QPjct-1-u4" href="#NWD0-H"><i>&lt;Read vertices triangles and textures&gt;</i></a>
    fclose(<a href="#NW0-1k8F3q-1">f</a>);
    <a href="#NWD0-E">printf</a>(&quot;\tDone!\n&quot;);
    return m;
}

</pre><blockquote><br>
This code is written to a file (or else not used).<p>
Defines <a href="#NWI-BUFF_SIZE"><code>BUFF_SIZE</code></a>, <a href="#NWI-freeModel"><code>freeModel</code></a> (links are to index).<p>
</blockquote><p>

Our data is stored in individual sections. Sections begin with <code>&lt;sectioname&gt;</code> tags, and end with <code>&lt;/sectionname&gt;</code> tags. The tags are on their own lines. Within a section, all lines that aren't empty or start with a <code>#</code> contain content.
<p>
Since we need to allocate memory for our data before we can read it, loading is a two-pass process. The first pass iterates over lines with fgets(), and counts all non-empty, non-comment lines between appropriate tags. To avoid copy and pasting similar code, a macro is used. <b>[</b>This could be done with a function, but error checking 
would make the code longer and more repetitive. Repetition leads to 
copy and paste, copy and paste leads to bugs just as insidious and
subtle as those caused by macros.
<p>
<a name="NWD0-E">The macro basically simulates an exception: unconditional return from a specific function, triggered by one of its' children. This could be implemented via setjmp.h, but I assume goto is even worse than macros!</a>
<p>
Macros do suck; however, copy and paste sucks more!
<b>]</b> 
<p>
Needless to say, string manipulation isn't the strong point of C. Excess whitespace should be dealt with by spaces around the <code>sscanf()</code> formats and <code>strstr()</code> rather than <code>strcmp()</code> tag searching, but comments not starting in the first column will break things, as will 'blank' lines with whitespace. So might many other things - the best I can promise is a semi-useful error message.
<p>

<pre><a name="NW0-2ElI3e-1" href="#NWD0-E"><dfn>&lt;Count and allocate memory for vertices triangles and textures&gt;=</dfn></a>
int <a href="#NWD0-E">ret</a>; // general-purpose return code holder

// read name while we're passing through
if (!<a href="#NWD0-F">seekstr</a>(<a href="#NW0-1k8F3q-1">f</a>,s,&quot;&lt;name&gt;&quot;)) return NULL;
fgets(s, <a href="#NWD0-D">BUFF_SIZE</a>, <a href="#NW0-1k8F3q-1">f</a>); // this keeps the \n at the end - should I fix it?
m-&gt;name = (char*)malloc(strlen(s)+1); // could just use strncpy and strlen-1...
strcpy(m-&gt;name, s); 
if (!<a href="#NWD0-F">seekstr</a>(<a href="#NW0-1k8F3q-1">f</a>,s,&quot;&lt;/name&gt;&quot;)) return NULL; 

// Helper macro, note the {...}! Not needed, but good practice.
// Since the scope, and usefulness of this macro is -extremely- local, the
//  benefit of brevity and readability outweighs the fact that macros suck.
#define <a href="#NWD0-E">COUNT_LINES</a>(start,stop,count) {                         \
    if (!<a href="#NWD0-F">seekstr</a>(<a href="#NW0-1k8F3q-1">f</a>,s,start)) return NULL;                       \
    while ((<a href="#NWD0-E">ret</a>=<a href="#NWD0-G">iter_line</a>(<a href="#NW0-1k8F3q-1">f</a>,s,stop))==<a href="#NWD0-G">ITER_NEXT</a>) (count)++;     \
    if (<a href="#NWD0-E">ret</a>==<a href="#NWD0-G">ITER_ERROR</a>) return NULL;                           \
                                      }
<a href="#NWD0-E">COUNT_LINES</a>(&quot;&lt;textures&gt;&quot;, &quot;&lt;/textures&gt;&quot;, m-&gt;num_tex);
<a href="#NWD0-E">COUNT_LINES</a>(&quot;&lt;vertices&gt;&quot;, &quot;&lt;/vertices&gt;&quot;, m-&gt;num_verts);
<a href="#NWD0-E">COUNT_LINES</a>(&quot;&lt;triangles&gt;&quot;, &quot;&lt;/triangles&gt;&quot;, m-&gt;num_tris);

// allocate space
m-&gt;tex = (<a href="#NWD0-J">texture</a>*)calloc(m-&gt;num_tex, sizeof(<a href="#NWD0-J">texture</a>));
m-&gt;verts = (vec3*)calloc(m-&gt;num_verts, sizeof(vec3));
m-&gt;tris = (<a href="#NWD0-B">triangle</a>*)calloc(m-&gt;num_tris, sizeof(<a href="#NWD0-B">triangle</a>));

<a href="#NWD0-E">printf</a>(&quot;\t%d bytes of memory allocated (%d*%dtex %d*%dvrt %d*%dtri)\n&quot;, 
        sizeof(<a href="#NWD0-J">texture</a>)*m-&gt;num_tex+sizeof(vec3)*m-&gt;num_verts
            +sizeof(<a href="#NWD0-B">triangle</a>)*m-&gt;num_tris+sizeof(<a href="#NWD0-B">model</a>),
        m-&gt;num_tex, sizeof(<a href="#NWD0-J">texture</a>),
        m-&gt;num_verts, sizeof(vec3),
        m-&gt;num_tris, sizeof(<a href="#NWD0-B">triangle</a>));
</pre><blockquote>Used <a href="#NWD0-D">above</a>.<p>
Defines <a href="#NWI-COUNT_LINES"><code>COUNT_LINES</code></a>, <a href="#NWI-printf"><code>printf</code></a>, <a href="#NWI-ret"><code>ret</code></a> (links are to index).<p>
</blockquote><p>

<a name="NWD0-F">To avoid (reduce) gratuitous copy and paste, some string IO utility functions have been implemented. The first simply seeks forward through a file until it passes a specific line. This is used to easily locate tags.</a>
<p>
<pre><a name="NW0-2qWIJb-1" href="#NWD0-F"><dfn>&lt;File IO utility functions&gt;=</dfn></a>
// Seek a needle line in a haystack of lines.
// Returns 1 on success, 0 on EOF or error.
int <a href="#NWD0-F">seekstr</a>(FILE* <a href="#NW0-1k8F3q-1">f</a>, char* s, const char* needle)
{
    // Be wary that due to how fgets works, lines longer than <a href="#NWD0-D">BUFF_SIZE</a>
    // will wreak havoc.
    // The needle can be part of the line, rather than whole. This
    // makes the code more robust with respect to excess whitespace.
    while (fgets(s, <a href="#NWD0-D">BUFF_SIZE</a>, <a href="#NW0-1k8F3q-1">f</a>)) {
        if (s[0]!='#' &amp;&amp; strstr(s,needle)) return 1;
    }
    if (feof(<a href="#NW0-1k8F3q-1">f</a>)) {
        fprintf(stderr,&quot;<a href="#NWD0-F">seekstr</a>() error: tag %s not found.\n&quot;, needle);
        return 0;
    }
    if (ferror(<a href="#NW0-1k8F3q-1">f</a>)) {
        perror(&quot;Error while seeking string in file&quot;); 
        return 0;
    }
    fprintf(stderr,&quot;Unknown <a href="#NWD0-F">seekstr</a>() error.\n&quot;);
    return 0;
}
</pre><blockquote>Used <a href="#NWD0-D">above</a>; <a href="#NWD0-G">next</a> definition.<p>
Defines <a href="#NWI-seekstr"><code>seekstr</code></a> (links are to index).<p>
</blockquote><p>

<a name="NWD0-G">The second utility function allows us to easily iterate over all lines in a section.</a>
<p>
<pre><a name="NW0-2qWIJb-2" href="#NWD0-F"><dfn>&lt;File IO utility functions&gt;+=</dfn></a>
// Reads the next non-comment, non-empty, non-stop line into s.
// Returns:
#define <a href="#NWD0-G">ITER_NEXT</a> 0 // on success
#define <a href="#NWD0-G">ITER_STOP</a> 1 // on encountering stop string
#define <a href="#NWD0-G">ITER_ERROR</a> 2 // on error/eof, prints error to stderr
int <a href="#NWD0-G">iter_line</a>(FILE* <a href="#NW0-1k8F3q-1">f</a>, char* s, const char* stop) 
{
    while (fgets(s, <a href="#NWD0-D">BUFF_SIZE</a>, <a href="#NW0-1k8F3q-1">f</a>)) {
        if ((s[0]=='#') | (s[0]=='\n')) continue; // skip comments/empty lines
        if (strstr(s,stop))
            return <a href="#NWD0-G">ITER_STOP</a>;
        else 
            return <a href="#NWD0-G">ITER_NEXT</a>;
    }
    // fgets failed - why?
    if (feof(<a href="#NW0-1k8F3q-1">f</a>)) {
        // if the file doesn't end with a \n, EOF is raised despite a valid
        // line being read - here's a handler for that edge case:
        //if (strstr(s,stop)) return <a href="#NWD0-G">ITER_STOP</a>;
        // since we know the file can't have useful data on the very last line
        // only <a href="#NWD0-G">ITER_STOP</a> must be handled
        fprintf(stderr,&quot;<a href="#NWD0-G">iter_line</a>() error: stop tag %s never found.\n&quot;, stop);
        return <a href="#NWD0-G">ITER_ERROR</a>;
    }
    if (ferror(<a href="#NW0-1k8F3q-1">f</a>)) {
        perror(&quot;Error while seeking string in file&quot;); 
        return <a href="#NWD0-G">ITER_ERROR</a>;
    }
    fprintf(stderr,&quot;Unknown <a href="#NWD0-G">iter_line</a>() error.\n&quot;);
    return <a href="#NWD0-G">ITER_ERROR</a>;
}
</pre><blockquote>Used <a href="#NWD0-D">above</a>; <a href="#NWD0-F">previous</a> definition.<p>
Defines <a href="#NWI-ITER_ERROR"><code>ITER_ERROR</code></a>, <a href="#NWI-iter_line"><code>iter_line</code></a>, <a href="#NWI-ITER_NEXT"><code>ITER_NEXT</code></a>, <a href="#NWI-ITER_STOP"><code>ITER_STOP</code></a> (links are to index).<p>
</blockquote><p>

<a name="NWD0-H">These utility functions let us neatly implement the second pass.</a>
<p>
The second pass in model loading actually uses scanf while iterating over all lines to read the detailed data the model consists of.
<p>
(Note that returning NULL without freeing allocated memory results in a memory leak, though with this kind of failure it hardly matters.)
<p>
<pre><a name="NW0-avNDO-1" href="#NWD0-H"><dfn>&lt;Read vertices triangles and textures&gt;=</dfn></a>
rewind(<a href="#NW0-1k8F3q-1">f</a>);
// not bothering to error check <a href="#NWD0-F">seekstr</a> since the first pass succeeded:
// on the off chance that reads start failing, stderr will get spammed
// with a few error messages then a scanf() will end up failing
// (so, loadModel's invariants still hold since NULL gets returned)
<a href="#NWD0-F">seekstr</a>(<a href="#NW0-1k8F3q-1">f</a>,s,&quot;&lt;textures&gt;&quot;);
for (<a href="#NWD0-B">list_index</a> i=0; <a href="#NWD0-G">iter_line</a>(<a href="#NW0-1k8F3q-1">f</a>,s,&quot;&lt;/textures&gt;&quot;)==<a href="#NWD0-G">ITER_NEXT</a>; i++) {
    // string manipulation in C is such a waste of time
    char path[<a href="#NWD0-D">BUFF_SIZE</a>]; path[0]=0;
    strcat(path, filepath);
    strcat(path, s);
    path[strlen(path)-1]=0; // cut off \n
    m-&gt;tex[i] = loadTexture(path);
    if (!m-&gt;tex[i].data) {
        fprintf(stderr, &quot;loadModel() failed: could not load <a href="#NWD0-J">texture</a>.\n&quot;);
        return NULL;
    }
}

// Note spaces at beginning and end of sscanf format string.
// These should get rid of any leading/trailing whitespace that comes up.

<a href="#NWD0-F">seekstr</a>(<a href="#NW0-1k8F3q-1">f</a>,s,&quot;&lt;vertices&gt;&quot;);
for (<a href="#NWD0-B">list_index</a> i=0; <a href="#NWD0-G">iter_line</a>(<a href="#NW0-1k8F3q-1">f</a>,s,&quot;&lt;/vertices&gt;&quot;)==<a href="#NWD0-G">ITER_NEXT</a>; i++) {
    vec3* v = &amp;m-&gt;verts[i]; // &amp; is lower precedence than -&gt; and []
    if (3!=sscanf(s, &quot; %<a href="#NW0-1k8F3q-1">f</a> %<a href="#NW0-1k8F3q-1">f</a> %<a href="#NW0-1k8F3q-1">f</a> &quot;, &amp;v-&gt;x, &amp;v-&gt;y, &amp;v-&gt;z)) {
        fprintf(stderr,&quot;loadModel(): error parsing vertex %d.\n&quot;, i);
        return NULL;
    }    
}

<a href="#NWD0-F">seekstr</a>(<a href="#NW0-1k8F3q-1">f</a>,s,&quot;&lt;triangles&gt;&quot;);
for (<a href="#NWD0-B">list_index</a> i=0; <a href="#NWD0-G">iter_line</a>(<a href="#NW0-1k8F3q-1">f</a>,s,&quot;&lt;/triangles&gt;&quot;)==<a href="#NWD0-G">ITER_NEXT</a>; i++) {
    <a href="#NWD0-B">triangle</a>* t = &amp;m-&gt;tris[i];
    if (13!=sscanf(s, &quot; %d %d %d %<a href="#NW0-1k8F3q-1">f</a> %<a href="#NW0-1k8F3q-1">f</a> %<a href="#NW0-1k8F3q-1">f</a> %d %<a href="#NW0-1k8F3q-1">f</a> %<a href="#NW0-1k8F3q-1">f</a> %<a href="#NW0-1k8F3q-1">f</a> %<a href="#NW0-1k8F3q-1">f</a> %<a href="#NW0-1k8F3q-1">f</a> %<a href="#NW0-1k8F3q-1">f</a> &quot;, 
                   &amp;t-&gt;a, &amp;t-&gt;b, &amp;t-&gt;c,      // vertex indexes
                   &amp;t-&gt;normal.x, &amp;t-&gt;normal.y, &amp;t-&gt;normal.z,
                   &amp;t-&gt;<a href="#NWD0-J">texture</a>,              // <a href="#NWD0-J">texture</a> index
                   &amp;t-&gt;tex_a.x, &amp;t-&gt;tex_a.y, // tex coordinate tuples
                   &amp;t-&gt;tex_b.x, &amp;t-&gt;tex_b.y, //  for each vertex
                   &amp;t-&gt;tex_c.x, &amp;t-&gt;tex_c.y)) {
        fprintf(stderr,&quot;loadModel(): error parsing <a href="#NWD0-B">triangle</a> %d.\n&quot;, i);
        return NULL;
    }    
}

</pre><blockquote>Used <a href="#NWD0-D">above</a>.<p>
</blockquote><p>


<h3><a name="NWD0-I">Rendering</a></h3>
<p>
The model data structure is fairly intuitive to render.
<p>
<pre><a name="NW0-jYM39-1" href="#NWD0-I"><dfn>&lt;render.h&gt;=</dfn></a>
<a name="NW0-jYM39-1-u1" href="#NWD0-T"><i>&lt;Copyright&gt;</i></a>
#ifndef <a href="#NWD0-I">_RENDER_H_</a>
#define <a href="#NWD0-I">_RENDER_H_</a>
#include &quot;<a href="#NWD0-B">model</a>.h&quot;

void <a href="#NW0-3OKV3b-1">renderModel</a>(<a href="#NWD0-B">model</a>* m);

#endif
</pre><blockquote><br>
This code is written to a file (or else not used).<p>
Defines <a href="#NWI-_RENDER_H_"><code>_RENDER_H_</code></a> (links are to index).<p>
</blockquote><p>

<pre><a name="NW0-3OKV3b-1" href="#NW0-3OKV3b-1"><dfn>&lt;render.c&gt;=</dfn></a>
<a name="NW0-3OKV3b-1-u1" href="#NWD0-T"><i>&lt;Copyright&gt;</i></a>
#include &quot;GL/gl.h&quot;
#include &quot;render.h&quot;

void <a href="#NW0-3OKV3b-1">renderModel</a>(<a href="#NWD0-B">model</a>* m)
{
    for (<a href="#NWD0-B">list_index</a> i=0; i&lt;m-&gt;num_tris; i++) {
        <a href="#NWD0-B">triangle</a>* tri = &amp;m-&gt;tris[i];
        vec3 v;

        // quick hacky way to get some colour
        //glColor3f((float)(i%100)/100+0.1,
        //          (float)((i-100)%100)/100+0.1, 
        //          (float)((i-200)%100)/100+0.1);

        if (m-&gt;num_tex) {
            glBindTexture(GL_TEXTURE_2D, m-&gt;tex[tri-&gt;<a href="#NWD0-J">texture</a>].id);
            glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE); 
        }

        glBegin(GL_TRIANGLES);

        v = m-&gt;verts[tri-&gt;a];
        glNormal3f(tri-&gt;normal.x,tri-&gt;normal.y,tri-&gt;normal.z);
        glTexCoord2f(tri-&gt;tex_a.x,tri-&gt;tex_a.y);
        glVertex3f(v.x,v.y,v.z);
        v = m-&gt;verts[tri-&gt;b];
        glNormal3f(tri-&gt;normal.x,tri-&gt;normal.y,tri-&gt;normal.z);
        glTexCoord2f(tri-&gt;tex_b.x,tri-&gt;tex_b.y);
        glVertex3f(v.x,v.y,v.z);
        v = m-&gt;verts[tri-&gt;c];
        glNormal3f(tri-&gt;normal.x,tri-&gt;normal.y,tri-&gt;normal.z);
        glTexCoord2f(tri-&gt;tex_c.x,tri-&gt;tex_c.y);
        glVertex3f(v.x,v.y,v.z);

        glEnd();
    }
}

</pre><blockquote><br>
This code is written to a file (or else not used).<p>
Defines <a href="#NWI-renderModel"><code>renderModel</code></a> (links are to index).<p>
</blockquote><p>

<h3><a name="NWD0-J">Textures</a></h3>
<p>
The code to load textures is a tad long, so it goes into separate files.
<p>
<pre><a name="NW0-3Qhn3o-1" href="#NWD0-J"><dfn>&lt;texture.h&gt;=</dfn></a>
#ifndef <a href="#NWD0-J">_TEXTURE_H_</a>
#define <a href="#NWD0-J">_TEXTURE_H_</a>

typedef struct <a href="#NWD0-J">texture</a> {
    unsigned int id;      // openGL <a href="#NWD0-J">texture</a> ID
    char* data;           // pixel buffer
    int width,height,bpp; // bytes per pixel
} <a href="#NWD0-J">texture</a>;

<a href="#NWD0-J">texture</a> loadTexture(const char* filename);
void <a href="#NW0-mDFBQ-1">freeTexture</a>(<a href="#NWD0-J">texture</a>* tex);

#endif
</pre><blockquote><br>
This code is written to a file (or else not used).<p>
Defines <a href="#NWI-_TEXTURE_H_"><code>_TEXTURE_H_</code></a>, <a href="#NWI-texture"><code>texture</code></a> (links are to index).<p>
</blockquote><p>

<pre><a name="NW0-mDFBQ-1" href="#NW0-mDFBQ-1"><dfn>&lt;texture.c&gt;=</dfn></a>
<a name="NW0-mDFBQ-1-u1" href="#NWD0-T"><i>&lt;Copyright&gt;</i></a>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;GL/gl.h&gt;
#include &quot;<a href="#NWD0-J">texture</a>.h&quot;

#define <a href="#NWD0-D">BUFF_SIZE</a> 1024
#define <a href="#NW0-mDFBQ-1">ERR_STR</a> &quot;loadTexture() error:&quot;
<a href="#NWD0-J">texture</a> loadTexture(const char* filename) {
    <a href="#NWD0-E">printf</a>(&quot;\tLoading [%s]...\n&quot;, filename);
    <a href="#NWD0-J">texture</a> tex;
    tex.data = NULL;

    FILE* <a href="#NW0-1k8F3q-1">f</a> = fopen(filename, &quot;rb&quot;);
    if (!<a href="#NW0-1k8F3q-1">f</a>) {perror(<a href="#NW0-mDFBQ-1">ERR_STR</a>); goto loadTexError;}
    char s [<a href="#NWD0-D">BUFF_SIZE</a>]; s[0]=0; // generic buffer
    int n; // generic counter
    // check magic word
    n = fread(s, 1, 2, <a href="#NW0-1k8F3q-1">f</a>); // read 2 one-byte blocks
    if (n!=2) {
        if (ferror(<a href="#NW0-1k8F3q-1">f</a>)) perror(<a href="#NW0-mDFBQ-1">ERR_STR</a>);
        if (feof(<a href="#NW0-1k8F3q-1">f</a>)) fprintf(stderr, &quot;%s <a href="#NWD0-J">texture</a> file %s too short!&quot;, 
                                                        <a href="#NW0-mDFBQ-1">ERR_STR</a>, filename);
        goto loadTexError;
    }
    if ((s[0]!='P') &amp; (s[1]!='6')) {
        fprintf(stderr, &quot;%s no magic byte found, non-PPM file!&quot;, <a href="#NW0-mDFBQ-1">ERR_STR</a>);
        goto loadTexError;
    }
    // read width, height, maxval
    retry: // goto sucks, but people who don't follow format definitions suck more
    if (3!=fscanf(<a href="#NW0-1k8F3q-1">f</a>, &quot; %d %d %d &quot;, &amp;tex.width, &amp;tex.height, &amp;tex.bpp)) {
        fgets(s,<a href="#NWD0-D">BUFF_SIZE</a>,<a href="#NW0-1k8F3q-1">f</a>);
        if (s[0]=='#' || s[0]=='\n') goto retry;
        fprintf(stderr, &quot;%s could not read header data.&quot;, <a href="#NW0-mDFBQ-1">ERR_STR</a>);
        goto loadTexError;
    }
    // should be &lt;, I think these ppm files are wrong
    tex.bpp = (tex.bpp&lt;=256) ? 1 : 2; 
    // read data
    int size = tex.width*tex.height*tex.bpp*3; // total size to read
    tex.data = (char*)malloc(size);
    if (size!=fread(tex.data, 1, size, <a href="#NW0-1k8F3q-1">f</a>)) {
        if (feof(<a href="#NW0-1k8F3q-1">f</a>)) fprintf(stderr, &quot;%s file too short!&quot;, <a href="#NW0-mDFBQ-1">ERR_STR</a>);
        if (ferror(<a href="#NW0-1k8F3q-1">f</a>)) perror(<a href="#NW0-mDFBQ-1">ERR_STR</a>);
    }
    <a href="#NWD0-E">printf</a>(&quot; (%d bytes)\n&quot;, size);
    fclose(<a href="#NW0-1k8F3q-1">f</a>);

    // now register the <a href="#NWD0-J">texture</a> with OpenGL
    glGenTextures(1, &amp;tex.id);
    glBindTexture(GL_TEXTURE_2D, tex.id);
    glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, tex.width, tex.height, 0,
                            GL_RGB, GL_UNSIGNED_BYTE, tex.data);
    
    // success, clean up and return <a href="#NWD0-J">texture</a>
    return tex;
    
    // poor man's exception handling (hey at least it's lightweight!)
    loadTexError:
    //free(tex);
    if (tex.data) free(tex.data);
    tex.data = NULL;
    //fclose(<a href="#NW0-1k8F3q-1">f</a>);
    return tex;
}

void <a href="#NW0-mDFBQ-1">freeTexture</a>(<a href="#NWD0-J">texture</a>* tex)
{
    if (tex-&gt;data) free(tex-&gt;data);
    if (tex) free(tex);
}
</pre><blockquote><br>
This code is written to a file (or else not used).<p>
Defines <a href="#NWI-BUFF_SIZE"><code>BUFF_SIZE</code></a>, <a href="#NWI-ERR_STR"><code>ERR_STR</code></a>, <a href="#NWI-freeTexture"><code>freeTexture</code></a> (links are to index).<p>
</blockquote><p>


<h2><a name="NWD0-K">City</a></h2>
<p>
A city is a group of models, transformed in various ways. It's described by a .city file. Two files, city.c and city.h provide access to it.
<p>
<h3>Data Representation</h3>
<p>
We need a data structure equivalent to the information stored in a .city file. This is done by having a simple city structure, containing an array of buildings. The buildings wrap size rotation and translation data around models.
<p>
<pre><a name="NW0-2iQFqO-1" href="#NWD0-K"><dfn>&lt;city.h&gt;=</dfn></a>
<a name="NW0-2iQFqO-1-u1" href="#NWD0-T"><i>&lt;Copyright&gt;</i></a>
#ifndef <a href="#NWD0-K">_CITY_H_</a>
#define <a href="#NWD0-K">_CITY_H_</a>
#include &quot;<a href="#NWD0-B">model</a>.h&quot;
#include &quot;vec.h&quot;

typedef struct <a href="#NWD0-K">building</a> {
    <a href="#NWD0-B">model</a>* <a href="#NWD0-B">model</a>;
    char* path;    // where to load <a href="#NWD0-B">model</a> from
    vec3 rt,tx,sc; // rotate translate scale
} <a href="#NWD0-K">building</a>;

typedef struct <a href="#NWD0-K">city</a> {
    char* name;
    <a href="#NWD0-B">list_index</a> num_buildings;
    <a href="#NWD0-K">building</a>* buildings;
} <a href="#NWD0-K">city</a>;
</pre><blockquote><a href="#NWD0-L">Next</a> definition.<br>
This code is written to a file (or else not used).<p>
Defines <a href="#NWI-_CITY_H_"><code>_CITY_H_</code></a>, <a href="#NWI-building"><code>building</code></a>, <a href="#NWI-city"><code>city</code></a> (links are to index).<p>
</blockquote><p>

<a name="NWD0-L">Like models, cities can be loaded and freed.</a>
<p>
<pre><a name="NW0-2iQFqO-2" href="#NWD0-K"><dfn>&lt;city.h&gt;+=</dfn></a>
<a href="#NWD0-K">city</a>* loadCity(char* file);
void <a href="#NWD0-O">freeCity</a>(<a href="#NWD0-K">city</a>* c);

#endif
</pre><blockquote><a href="#NWD0-K">Previous</a> definition.<p>
</blockquote><p>

<h3><a name="NWD0-M">Loading</a></h3>
<p>
<pre><a name="NW0-6CV0W-1" href="#NWD0-M"><dfn>&lt;city.c&gt;=</dfn></a>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &quot;<a href="#NWD0-K">city</a>.h&quot;
#include &quot;<a href="#NWD0-B">model</a>.h&quot;
<a name="NW0-6CV0W-1-u1" href="#NWD0-N"><i>&lt;Loading a city&gt;</i></a>
<a name="NW0-6CV0W-1-u2" href="#NWD0-O"><i>&lt;Freeing a city&gt;</i></a>
</pre><blockquote><br>
This code is written to a file (or else not used).<p>
</blockquote><p>

<a name="NWD0-N">The file format is significantly simpler than for models, which shortens the code significantly.</a>
<p>
I should technically cleanup before returning, probably using an exception-like goto to do a freeCity() in the end, instead of just a return NULL. However, loadCity is currently a once-in-a-lifetime function so there's no point. Minor memory leaks are tolerable in this case.
<p>
<pre><a name="NW0-4JlH4p-1" href="#NWD0-N"><dfn>&lt;Loading a city&gt;=</dfn></a>
<a href="#NWD0-K">city</a>* loadCity(char* file)
{
    <a href="#NWD0-E">printf</a>(&quot;Loading <a href="#NWD0-K">city</a>: %s\n&quot;, file);
    FILE* <a href="#NW0-1k8F3q-1">f</a> = fopen(file, &quot;rb&quot;);
    if (!<a href="#NW0-1k8F3q-1">f</a>) {perror(&quot;loadCity() error:&quot;); return NULL;}
    // memory allocation
    #define BUF_SIZE 4096
    <a href="#NWD0-K">city</a>* c = (<a href="#NWD0-K">city</a>*)calloc(1, sizeof(<a href="#NWD0-K">city</a>));
    char* s = (char*)malloc(BUF_SIZE);
    // useful macro to get first noncomment/nonempty line
    // (scope local to this function)
    // inlines excessively, but eh, I'm in a hurry :)
    #define FETCH_LINE {do {                                                  \
        if (!fgets(s, BUF_SIZE, <a href="#NW0-1k8F3q-1">f</a>)) {                                         \
            if (feof(<a href="#NW0-1k8F3q-1">f</a>))                                                      \
                fprintf(stderr, &quot;loadCity() error: file ended too soon!\n&quot;);  \
            if (ferror(<a href="#NW0-1k8F3q-1">f</a>))                                                    \
                perror(&quot;loadCity() error reading file:&quot;);                     \
            return NULL;                                                      \
        }                                                                     \
    } while (s[0]=='\n' || s[0]=='#');} // find nonblank noncomment lines
    // get name
    FETCH_LINE;
    c-&gt;name = (char*)malloc(strlen(s)+1);
    strcpy(c-&gt;name, s);
    // get number of models in <a href="#NWD0-K">city</a>
    FETCH_LINE;
    if (1!=sscanf(s, &quot; %d &quot;, &amp;c-&gt;num_buildings)) {
        fprintf(stderr, &quot;loadCity() error: could not read number of buildings.\n&quot;);
        return NULL;
    }
    // allocate memory for buildings
    c-&gt;buildings = (<a href="#NWD0-K">building</a>*)calloc(c-&gt;num_buildings, sizeof(<a href="#NWD0-K">building</a>));
    // load models!
    for (<a href="#NWD0-B">list_index</a> i=0; i&lt;c-&gt;num_buildings; i++) {
        FETCH_LINE;
        <a href="#NWD0-K">building</a>* b = &amp;c-&gt;buildings[i];
        b-&gt;path = (char*)malloc(512);
        int <a href="#NWD0-E">ret</a> = sscanf(s, &quot;%s %<a href="#NW0-1k8F3q-1">f</a> %<a href="#NW0-1k8F3q-1">f</a> %<a href="#NW0-1k8F3q-1">f</a> %<a href="#NW0-1k8F3q-1">f</a> %<a href="#NW0-1k8F3q-1">f</a> %<a href="#NW0-1k8F3q-1">f</a> %<a href="#NW0-1k8F3q-1">f</a> %<a href="#NW0-1k8F3q-1">f</a> %<a href="#NW0-1k8F3q-1">f</a> &quot;, b-&gt;path,
                                           &amp;b-&gt;sc.x, &amp;b-&gt;sc.y, &amp;b-&gt;sc.z,
                                           &amp;b-&gt;rt.x, &amp;b-&gt;rt.y, &amp;b-&gt;rt.z,
                                           &amp;b-&gt;tx.x, &amp;b-&gt;tx.y, &amp;b-&gt;tx.z);
        if (<a href="#NWD0-E">ret</a>!=10) {
            fprintf(stderr, &quot;loadCity() error while parsing <a href="#NWD0-K">building</a> #%d, &quot;
                            &quot;only %d parameters read! &lt;%s&gt;\n&quot;, i+1, <a href="#NWD0-E">ret</a>, s);
            return NULL;
        }
        b-&gt;<a href="#NWD0-B">model</a> = loadModel(c-&gt;buildings[i].path);
        if (!b-&gt;<a href="#NWD0-B">model</a>) {
            fprintf(stderr, &quot;loadCity() exiting due to <a href="#NWD0-B">model</a> load failure.&quot;);
            return NULL;
        }
    }
    free(s);
    return c;
}
</pre><blockquote>Used <a href="#NWD0-M">above</a>.<p>
</blockquote><p>

<a name="NWD0-O">Freeing the city is as simple as ensuring all allocated memory gets cleaned.</a>
<p>
<pre><a name="NW0-1YTnM8-1" href="#NWD0-O"><dfn>&lt;Freeing a city&gt;=</dfn></a>
void <a href="#NWD0-O">freeCity</a>(<a href="#NWD0-K">city</a>* c)
{
    if (c-&gt;name) free(c-&gt;name);
    for (<a href="#NWD0-B">list_index</a> i; i&lt;c-&gt;num_buildings; i++) {
        <a href="#NWD0-D">freeModel</a>(c-&gt;buildings[i].<a href="#NWD0-B">model</a>);
        free(c-&gt;buildings[i].path);
    }
    if (c-&gt;buildings) free(c-&gt;buildings);
}
</pre><blockquote>Used <a href="#NWD0-M">above</a>.<p>
Defines <a href="#NWI-freeCity"><code>freeCity</code></a> (links are to index).<p>
</blockquote><p>

<h3><a name="NWD0-P">Initializing</a></h3>
<p>
The city gets loaded if a parameter gets passed to the executable. A non-null &quot;city&quot; pointer means the renderer should probably display a movie in that city.
<p>
<pre><a name="NW0-1Abiqb-4" href="#NWD0-2"><dfn>&lt;Main includes&gt;+=</dfn></a>
#include &quot;<a href="#NWD0-K">city</a>.h&quot;
</pre><blockquote>Used <a href="#NWD0-1">above</a>; <a href="#NWD0-A">previous</a> definition.<p>
</blockquote><p>

<pre><a name="NW0-3PmW1A-3" href="#NWD0-3"><dfn>&lt;Globals&gt;+=</dfn></a>
<a href="#NWD0-K">city</a>* acity = NULL;
</pre><blockquote>Used <a href="#NWD0-1">above</a>; <a href="#NW0-3PmW1A-2">previous</a> and <a href="#NWD0-Q">next</a> definitions.<p>
</blockquote><p>

<pre><a name="NW0-2ob9xm-5" href="#NW0-2ob9xm-1"><dfn>&lt;Global initialization&gt;+=</dfn></a>
if (argc==2) {
    acity = loadCity(argv[1]);
}
</pre><blockquote>Used <a href="#NWD0-1">above</a>; <a href="#NW0-2ob9xm-4">previous</a> definition.<p>
</blockquote><p>

<pre><a name="NW0-3C82A9-2" href="#NW0-3C82A9-1"><dfn>&lt;Global cleanup&gt;+=</dfn></a>
if (acity) <a href="#NWD0-O">freeCity</a>(acity);
</pre><blockquote>Used <a href="#NWD0-1">above</a>; <a href="#NW0-3C82A9-1">previous</a> definition.<p>
</blockquote><p>

<h3><a name="NWD0-Q">Rendering</a></h3>
<p>
<pre><a name="NW0-3PmW1A-4" href="#NWD0-3"><dfn>&lt;Globals&gt;+=</dfn></a>
int <a href="#NWD0-Q">frameCounter</a>=0;
</pre><blockquote>Used <a href="#NWD0-1">above</a>; <a href="#NW0-3PmW1A-3">previous</a> definition.<p>
Defines <a href="#NWI-frameCounter"><code>frameCounter</code></a> (links are to index).<p>
</blockquote><p>

<pre><a name="NW0-1k8F3q-1" href="#NW0-1k8F3q-1"><dfn>&lt;Render city&gt;=</dfn></a>
glEnable(GL_TEXTURE_2D);
// render them buildings
for (<a href="#NWD0-B">list_index</a> i=0; i&lt;acity-&gt;num_buildings; i++) {
    <a href="#NWD0-K">building</a>* b = &amp;acity-&gt;buildings[i];
    glPushMatrix();
        glTranslatef(b-&gt;tx.x, b-&gt;tx.y, b-&gt;tx.z);
        glScalef(b-&gt;sc.x, b-&gt;sc.y, b-&gt;sc.z);
        glRotatef(b-&gt;rt.z, 0, 0, 1);
        glRotatef(b-&gt;rt.y, 0, 1, 0);
        glRotatef(b-&gt;rt.x, 1, 0, 0);
        <a href="#NW0-3OKV3b-1">renderModel</a>(b-&gt;<a href="#NWD0-B">model</a>);
    glPopMatrix();

}
char* <a href="#NW0-1k8F3q-1">buff</a> = (char*)malloc(640*480*3);
char <a href="#NW0-1k8F3q-1">fname</a>[256]; <a href="#NW0-1k8F3q-1">fname</a>[0]=0; sprintf(<a href="#NW0-1k8F3q-1">fname</a>, &quot;out/%d.ppm&quot;, <a href="#NWD0-Q">frameCounter</a>);
FILE* <a href="#NW0-1k8F3q-1">f</a> = fopen(<a href="#NW0-1k8F3q-1">fname</a>, &quot;wb&quot;);
glReadPixels(0,0,640,480,GL_RGB,GL_UNSIGNED_BYTE,(void*)<a href="#NW0-1k8F3q-1">buff</a>);
fprintf(<a href="#NW0-1k8F3q-1">f</a>, &quot;P6\n640\n480\n255\n&quot;);
fwrite(<a href="#NW0-1k8F3q-1">buff</a>, 1, 640*480*3, <a href="#NW0-1k8F3q-1">f</a>);
fclose(<a href="#NW0-1k8F3q-1">f</a>);

<a href="#NWD0-Q">frameCounter</a>++;
</pre><blockquote>Used <a href="#NWD0-8">above</a>.<p>
Defines <a href="#NWI-buff"><code>buff</code></a>, <a href="#NWI-f"><code>f</code></a>, <a href="#NWI-fname"><code>fname</code></a> (links are to index).<p>
</blockquote><p>

<h2><a name="NWD0-R">Utility</a></h2>
<p>
<h3>Vectors</h3>
<p>
2D and 3D vectors are useful things, but not in the C stdlib. I use them to neatly represent the model data structure, and in the camera controls, to name two places.
<p>
<pre><a name="NW0-JuB2O-1" href="#NWD0-R"><dfn>&lt;vec.h&gt;=</dfn></a>
<a name="NW0-JuB2O-1-u1" href="#NWD0-T"><i>&lt;Copyright&gt;</i></a>
#ifndef <a href="#NWD0-R">_VEC_H_</a>
#define <a href="#NWD0-R">_VEC_H_</a>

typedef struct vec3 {float x,y,z;} vec3;
typedef struct vec2 {float x,y;} vec2;

float <a href="#NWD0-S">dot</a>(vec3 a, vec3 b);
vec3 cross(vec3 a, vec3 b);
void <a href="#NWD0-S">normalize</a>(vec3* v);

#endif
</pre><blockquote><br>
This code is written to a file (or else not used).<p>
Defines <a href="#NWI-_VEC_H_"><code>_VEC_H_</code></a> (links are to index).<p>
</blockquote><p>

<a name="NWD0-S">The struct initialization syntax used in cross() is worth noting. It has a major advantage over other methods, in that the names can be out of order. A disadvantage is that you can skip fields, and the compiler will silently set them to a default. (Probably zero.)</a>
<p>
<pre><a name="NW0-2M4sM4-1" href="#NWD0-S"><dfn>&lt;vec.c&gt;=</dfn></a>
<a name="NW0-2M4sM4-1-u1" href="#NWD0-T"><i>&lt;Copyright&gt;</i></a>
#include &quot;vec.h&quot;
#include &lt;math.h&gt;

float <a href="#NWD0-S">dot</a>(vec3 a, vec3 b) {
    return a.x*b.x + a.y*b.y + a.z*b.z;
};

vec3 cross(vec3 a, vec3 b) {
    // rarely used, but kinda cool syntax:
    return (vec3){. x = a.y*b.z - a.z*b.y
                 ,. y = a.z*b.x - a.x*b.z
                 ,. z = a.x*b.y - a.y*b.x
                 };
};

void <a href="#NWD0-S">normalize</a>(vec3* v) {
    float scale = sqrt(v-&gt;z*v-&gt;z + v-&gt;x*v-&gt;x + v-&gt;y*v-&gt;y);
    v-&gt;x/=scale;
    v-&gt;y/=scale;
    v-&gt;z/=scale;
}

</pre><blockquote><br>
This code is written to a file (or else not used).<p>
Defines <a href="#NWI-dot"><code>dot</code></a>, <a href="#NWI-normalize"><code>normalize</code></a> (links are to index).<p>
</blockquote><p>

<h3><a name="NWD0-T">Copyright</a></h3>
<p>
Including a header with copyright information, credits, and a brief list of recent changes is good practice. In this case, I'm also required to do so by the assignment.
<p>
By using literate programming and putting this header in a separate chunk, much copy and pasting is eliminated!
<p><pre><a name="NW0-43NTaN-1" href="#NWD0-T"><dfn>&lt;Copyright&gt;=</dfn></a>
/**
 *  <a href="#NWD0-U">AUTHOR</a>: Alex Kropivny
 *  Copyright information, TODO
 *
 *  Please see accompanying PDF/HTML file for full comments and documentation!
 */
</pre><blockquote>Used <a href="#NWD0-1">above (1)</a>, <a href="#NWD0-B">above (2)</a>, <a href="#NWD0-C">above (3)</a>, <a href="#NWD0-D">above (4)</a>, <a href="#NWD0-I">above (5)</a>, <a href="#NW0-3OKV3b-1">above (6)</a>, <a href="#NW0-mDFBQ-1">above (7)</a>, <a href="#NWD0-K">above (8)</a>, <a href="#NWD0-R">above (9)</a>, <a href="#NWD0-S">above (10)</a>.<p>
</blockquote><p>

<a name="NWD0-U">The only other place where my name appears is the definition in main, for the function that draw it on the screen.</a>
<p><pre><a name="NW0-4D2mev-1" href="#NWD0-U"><dfn>&lt;Name definition&gt;=</dfn></a>
#define <a href="#NWD0-U">AUTHOR</a> &quot;Alex Kropivny&quot;
</pre><blockquote>Used <a href="#NWD0-8">above</a>.<p>
Defines <a href="#NWI-AUTHOR"><code>AUTHOR</code></a> (links are to index).<p>
</blockquote><p>

<h3><a name="NWD0-V">Test Functions</a></h3>
<p>
The following code was provided by the course instructor.
<p><pre><a name="NW0-2xKkc5-1" href="#NWD0-V"><dfn>&lt;Test render functions&gt;=</dfn></a>
// The following code (<a href="#NWD0-V">Cube</a>() and <a href="#NWD0-V">Axes</a>()) is not mine. It was provided by the
// the instructor for the course.
void <a href="#NWD0-V">Cube</a>()
{
    glBegin(GL_QUADS);
        glColor3f(0.0f,1.0f,0.0f);          // Set The Color To Green
        glVertex3f( 1.0f, 1.0f,-1.0f);          // Top Right Of The Quad (Top)
        glVertex3f(-1.0f, 1.0f,-1.0f);          // Top Left Of The Quad (Top)
        glVertex3f(-1.0f, 1.0f, 1.0f);          // Bottom Left Of The Quad (Top)
        glVertex3f( 1.0f, 1.0f, 1.0f);          // Bottom Right Of The Quad (Top)
        glColor3f(1.0f,0.5f,0.0f);          // Set The Color To Orange
        glVertex3f( 1.0f,-1.0f, 1.0f);          // Top Right Of The Quad (Bottom)
        glVertex3f(-1.0f,-1.0f, 1.0f);          // Top Left Of The Quad (Bottom)
        glVertex3f(-1.0f,-1.0f,-1.0f);          // Bottom Left Of The Quad (Bottom)
        glVertex3f( 1.0f,-1.0f,-1.0f);          // Bottom Right Of The Quad (Bottom)
        glColor3f(1.0f,0.0f,0.0f);          // Set The Color To Red
        glVertex3f( 1.0f, 1.0f, 1.0f);          // Top Right Of The Quad (Front)
        glVertex3f(-1.0f, 1.0f, 1.0f);          // Top Left Of The Quad (Front)
        glVertex3f(-1.0f,-1.0f, 1.0f);          // Bottom Left Of The Quad (Front)
        glVertex3f( 1.0f,-1.0f, 1.0f);          // Bottom Right Of The Quad (Front)
        glColor3f(1.0f,1.0f,0.0f);          // Set The Color To Yellow
        glVertex3f( 1.0f,-1.0f,-1.0f);          // Bottom Left Of The Quad (Back)
        glVertex3f(-1.0f,-1.0f,-1.0f);          // Bottom Right Of The Quad (Back)
        glVertex3f(-1.0f, 1.0f,-1.0f);          // Top Right Of The Quad (Back)
        glVertex3f( 1.0f, 1.0f,-1.0f);          // Top Left Of The Quad (Back)
        glColor3f(0.0f,0.0f,1.0f);          // Set The Color To Blue
        glVertex3f(-1.0f, 1.0f, 1.0f);          // Top Right Of The Quad (Left)
        glVertex3f(-1.0f, 1.0f,-1.0f);          // Top Left Of The Quad (Left)
        glVertex3f(-1.0f,-1.0f,-1.0f);          // Bottom Left Of The Quad (Left)
        glVertex3f(-1.0f,-1.0f, 1.0f);          // Bottom Right Of The Quad (Left)
        glColor3f(1.0f,0.0f,1.0f);          // Set The Color To Violet
        glVertex3f( 1.0f, 1.0f,-1.0f);          // Top Right Of The Quad (Right)
        glVertex3f( 1.0f, 1.0f, 1.0f);          // Top Left Of The Quad (Right)
        glVertex3f( 1.0f,-1.0f, 1.0f);          // Bottom Left Of The Quad (Right)
        glVertex3f( 1.0f,-1.0f,-1.0f);          // Bottom Right Of The Quad (Right)
    glEnd();                        // Done Drawing The Quad
}           

void <a href="#NWD0-V">Axes</a>()
{
    glScalef(10,10,10);
    glBegin(GL_LINES); {
        // Axis
        glColor3f(0.0f, 1.0f, 1.0f);
        glVertex3f(0.0f, 0.0f, 0.0f);
        glVertex3f(1.0f, 0.0f, 0.0f);
        
        // Axis
        glColor3f(0.0f, 1.0f, 0.0f);
        glVertex3f(0.0f, 0.0f, 0.0f);
        glVertex3f(0.0f, 1.0f, 0.0f);
        
        // Axis
        glColor3f(0.0f, 0.0f, 1.0f);
        glVertex3f(0.0f, 0.0f, 0.0f);
        glVertex3f(0.0f, 0.0f, 1.0f);
    } glEnd();
    glScalef(0.1,0.1,0.1);
}
    
</pre><blockquote>Used <a href="#NWD0-8">above</a>.<p>
Defines <a href="#NWI-Axes"><code>Axes</code></a>, <a href="#NWI-Cube"><code>Cube</code></a> (links are to index).<p>
</blockquote><p>

<h2><a name="NWD0-W">Index</a></h2>
<p>
<nowebindex>


<ul>
<li><a name="NWI-_CITY_H_" href="#NWD0-K">_CITY_H_</a>: <a href="#NWD0-K">D1</a>
<li><a name="NWI-_LOAD_H_" href="#NWD0-C">_LOAD_H_</a>: <a href="#NWD0-C">D1</a>
<li><a name="NWI-_MODEL_H_" href="#NWD0-B">_MODEL_H_</a>: <a href="#NWD0-B">D1</a>
<li><a name="NWI-_RENDER_H_" href="#NWD0-I">_RENDER_H_</a>: <a href="#NWD0-I">D1</a>
<li><a name="NWI-_TEXTURE_H_" href="#NWD0-J">_TEXTURE_H_</a>: <a href="#NWD0-J">D1</a>
<li><a name="NWI-_VEC_H_" href="#NWD0-R">_VEC_H_</a>: <a href="#NWD0-R">D1</a>
<li><a name="NWI-AUTHOR" href="#NWD0-U">AUTHOR</a>: <a href="#NWD0-8">U1</a>, <a href="#NWD0-T">U2</a>, <a href="#NWD0-U">D3</a>
<li><a name="NWI-Axes" href="#NWD0-V">Axes</a>: <a href="#NWD0-8">U1</a>, <a href="#NWD0-V">D2</a>
<li><a name="NWI-buff" href="#NW0-1k8F3q-1">buff</a>: <a href="#NW0-1k8F3q-1">D1</a>
<li><a name="NWI-BUFF_SIZE" href="#NWD0-D">BUFF_SIZE</a>: <a href="#NWD0-D">D1</a>, <a href="#NWD0-E">U2</a>, <a href="#NWD0-F">U3</a>, <a href="#NWD0-G">U4</a>, <a href="#NWD0-H">U5</a>, <a href="#NW0-mDFBQ-1">D6</a>
<li><a name="NWI-building" href="#NWD0-K">building</a>: <a href="#NWD0-K">D1</a>, <a href="#NWD0-N">U2</a>, <a href="#NW0-1k8F3q-1">U3</a>
<li><a name="NWI-city" href="#NWD0-K">city</a>: <a href="#NWD0-K">D1</a>, <a href="#NWD0-L">U2</a>, <a href="#NWD0-M">U3</a>, <a href="#NWD0-N">U4</a>, <a href="#NWD0-O">U5</a>, <a href="#NWD0-P">U6</a>, <a href="#NW0-3PmW1A-3">U7</a>
<li><a name="NWI-cleanup" href="#NWD0-1">cleanup</a>: <a href="#NWD0-1">D1</a>, <a href="#NW0-2ob9xm-1">U2</a>
<li><a name="NWI-click" href="#NW0-1FaN2o-4">click</a>: <a href="#NW0-2ob9xm-1">U1</a>, <a href="#NW0-1FaN2o-4">D2</a>
<li><a name="NWI-COUNT_LINES" href="#NWD0-E">COUNT_LINES</a>: <a href="#NWD0-E">D1</a>
<li><a name="NWI-Cube" href="#NWD0-V">Cube</a>: <a href="#NWD0-8">U1</a>, <a href="#NWD0-V">D2</a>
<li><a name="NWI-display" href="#NWD0-8">display</a>: <a href="#NW0-2ob9xm-1">U1</a>, <a href="#NWD0-8">D2</a>
<li><a name="NWI-do_lighting" href="#NWD0-3">do_lighting</a>: <a href="#NWD0-3">D1</a>, <a href="#NW0-1FaN2o-1">U2</a>, <a href="#NWD0-8">U3</a>
<li><a name="NWI-do_textures" href="#NWD0-3">do_textures</a>: <a href="#NWD0-3">D1</a>, <a href="#NW0-1FaN2o-1">U2</a>, <a href="#NW0-3j0qiB-1">U3</a>
<li><a name="NWI-dot" href="#NWD0-S">dot</a>: <a href="#NW0-1FaN2o-4">U1</a>, <a href="#NWD0-R">U2</a>, <a href="#NWD0-S">D3</a>
<li><a name="NWI-DRAW_AXES" href="#NWD0-3">DRAW_AXES</a>: <a href="#NWD0-3">D1</a>, <a href="#NW0-1FaN2o-1">U2</a>, <a href="#NWD0-8">U3</a>
<li><a name="NWI-DRAW_CUBE" href="#NWD0-3">DRAW_CUBE</a>: <a href="#NWD0-3">D1</a>, <a href="#NWD0-8">U2</a>
<li><a name="NWI-DRAW_MODEL" href="#NWD0-3">DRAW_MODEL</a>: <a href="#NWD0-3">D1</a>, <a href="#NWD0-8">U2</a>
<li><a name="NWI-DRAW_TEAPOT" href="#NWD0-3">DRAW_TEAPOT</a>: <a href="#NWD0-3">D1</a>, <a href="#NWD0-8">U2</a>
<li><a name="NWI-ERR_STR" href="#NW0-mDFBQ-1">ERR_STR</a>: <a href="#NW0-mDFBQ-1">D1</a>
<li><a name="NWI-f" href="#NW0-1k8F3q-1">f</a>: <a href="#NW0-2f73Kx-1">U1</a>, <a href="#NW0-1FaN2o-4">U2</a>, <a href="#NWD0-D">U3</a>, <a href="#NWD0-E">U4</a>, <a href="#NWD0-F">U5</a>, <a href="#NWD0-G">U6</a>, <a href="#NWD0-H">U7</a>, <a href="#NW0-mDFBQ-1">U8</a>, <a href="#NWD0-N">U9</a>, <a href="#NW0-1k8F3q-1">D10</a>
<li><a name="NWI-fname" href="#NW0-1k8F3q-1">fname</a>: <a href="#NW0-1k8F3q-1">D1</a>
<li><a name="NWI-frameCounter" href="#NWD0-Q">frameCounter</a>: <a href="#NWD0-Q">D1</a>, <a href="#NW0-1k8F3q-1">U2</a>
<li><a name="NWI-freeCity" href="#NWD0-O">freeCity</a>: <a href="#NWD0-L">U1</a>, <a href="#NWD0-O">D2</a>, <a href="#NW0-3C82A9-2">U3</a>
<li><a name="NWI-freeModel" href="#NWD0-D">freeModel</a>: <a href="#NW0-3C82A9-1">U1</a>, <a href="#NWD0-C">U2</a>, <a href="#NWD0-D">D3</a>, <a href="#NWD0-O">U4</a>
<li><a name="NWI-freeTexture" href="#NW0-mDFBQ-1">freeTexture</a>: <a href="#NWD0-J">U1</a>, <a href="#NW0-mDFBQ-1">D2</a>
<li><a name="NWI-ITER_ERROR" href="#NWD0-G">ITER_ERROR</a>: <a href="#NWD0-E">U1</a>, <a href="#NWD0-G">D2</a>
<li><a name="NWI-iter_line" href="#NWD0-G">iter_line</a>: <a href="#NWD0-E">U1</a>, <a href="#NWD0-G">D2</a>, <a href="#NWD0-H">U3</a>
<li><a name="NWI-ITER_NEXT" href="#NWD0-G">ITER_NEXT</a>: <a href="#NWD0-E">U1</a>, <a href="#NWD0-G">D2</a>, <a href="#NWD0-H">U3</a>
<li><a name="NWI-ITER_STOP" href="#NWD0-G">ITER_STOP</a>: <a href="#NWD0-G">D1</a>
<li><a name="NWI-keyboard" href="#NW0-1FaN2o-1">keyboard</a>: <a href="#NW0-2ob9xm-1">U1</a>, <a href="#NW0-1FaN2o-1">D2</a>
<li><a name="NWI-list_index" href="#NWD0-B">list_index</a>: <a href="#NWD0-B">D1</a>, <a href="#NWD0-H">U2</a>, <a href="#NW0-3OKV3b-1">U3</a>, <a href="#NWD0-K">U4</a>, <a href="#NWD0-N">U5</a>, <a href="#NWD0-O">U6</a>, <a href="#NW0-1k8F3q-1">U7</a>
<li><a name="NWI-lmbDown" href="#NWD0-3">lmbDown</a>: <a href="#NWD0-3">D1</a>, <a href="#NW0-1FaN2o-4">U2</a>
<li><a name="NWI-main" href="#NWD0-1">main</a>: <a href="#NWD0-1">D1</a>
<li><a name="NWI-MIN" href="#NW0-1FaN2o-4">MIN</a>: <a href="#NW0-1FaN2o-4">D1</a>
<li><a name="NWI-model" href="#NWD0-B">model</a>: <a href="#NW0-1FaN2o-1">U1</a>, <a href="#NW0-3PmW1A-2">U2</a>, <a href="#NW0-2ob9xm-4">U3</a>, <a href="#NWD0-B">D4</a>, <a href="#NWD0-C">U5</a>, <a href="#NWD0-D">U6</a>, <a href="#NWD0-E">U7</a>, <a href="#NWD0-I">U8</a>, <a href="#NW0-3OKV3b-1">U9</a>, <a href="#NWD0-K">U10</a>, <a href="#NWD0-M">U11</a>, <a href="#NWD0-N">U12</a>, <a href="#NWD0-O">U13</a>, <a href="#NW0-1k8F3q-1">U14</a>
<li><a name="NWI-MODEL_FILE" href="#NW0-2ob9xm-4">MODEL_FILE</a>: <a href="#NW0-2ob9xm-4">D1</a>
<li><a name="NWI-motion" href="#NW0-1FaN2o-4">motion</a>: <a href="#NW0-2ob9xm-1">U1</a>, <a href="#NW0-1FaN2o-4">D2</a>
<li><a name="NWI-normalize" href="#NWD0-S">normalize</a>: <a href="#NW0-1FaN2o-4">U1</a>, <a href="#NWD0-R">U2</a>, <a href="#NWD0-S">D3</a>
<li><a name="NWI-PI" href="#NW0-1FaN2o-4">PI</a>: <a href="#NW0-1FaN2o-4">D1</a>
<li><a name="NWI-printf" href="#NWD0-E">printf</a>: <a href="#NW0-1FaN2o-4">U1</a>, <a href="#NWD0-D">U2</a>, <a href="#NWD0-E">D3</a>, <a href="#NW0-mDFBQ-1">U4</a>, <a href="#NWD0-N">U5</a>
<li><a name="NWI-RAD_TO_DEG" href="#NW0-1FaN2o-4">RAD_TO_DEG</a>: <a href="#NW0-1FaN2o-4">D1</a>
<li><a name="NWI-renderModel" href="#NW0-3OKV3b-1">renderModel</a>: <a href="#NW0-3j0qiB-1">U1</a>, <a href="#NWD0-I">U2</a>, <a href="#NW0-3OKV3b-1">D3</a>, <a href="#NW0-1k8F3q-1">U4</a>
<li><a name="NWI-renderName" href="#NWD0-8">renderName</a>: <a href="#NWD0-8">D1</a>
<li><a name="NWI-reshape" href="#NWD0-5">reshape</a>: <a href="#NW0-2ob9xm-1">U1</a>, <a href="#NWD0-5">D2</a>
<li><a name="NWI-ret" href="#NWD0-E">ret</a>: <a href="#NWD0-E">D1</a>, <a href="#NWD0-N">U2</a>
<li><a name="NWI-rotCam" href="#NW0-2f73Kx-1">rotCam</a>: <a href="#NWD0-6">U1</a>, <a href="#NW0-2f73Kx-1">D2</a>
<li><a name="NWI-seekstr" href="#NWD0-F">seekstr</a>: <a href="#NWD0-E">U1</a>, <a href="#NWD0-F">D2</a>, <a href="#NWD0-H">U3</a>
<li><a name="NWI-special_key" href="#NWD0-6">special_key</a>: <a href="#NW0-2ob9xm-1">U1</a>, <a href="#NWD0-6">D2</a>
<li><a name="NWI-texture" href="#NWD0-J">texture</a>: <a href="#NWD0-B">U1</a>, <a href="#NWD0-E">U2</a>, <a href="#NWD0-H">U3</a>, <a href="#NW0-3OKV3b-1">U4</a>, <a href="#NWD0-J">D5</a>, <a href="#NW0-mDFBQ-1">U6</a>
<li><a name="NWI-triangle" href="#NWD0-B">triangle</a>: <a href="#NWD0-B">D1</a>, <a href="#NWD0-E">U2</a>, <a href="#NWD0-H">U3</a>, <a href="#NW0-3OKV3b-1">U4</a>
<li><a name="NWI-what_to_draw" href="#NWD0-3">what_to_draw</a>: <a href="#NWD0-3">D1</a>, <a href="#NW0-1FaN2o-1">U2</a>, <a href="#NWD0-8">U3</a>
<li><a name="NWI-winHeight" href="#NWD0-3">winHeight</a>: <a href="#NW0-2ob9xm-1">U1</a>, <a href="#NWD0-3">D2</a>, <a href="#NWD0-5">U3</a>, <a href="#NW0-1FaN2o-4">U4</a>, <a href="#NWD0-8">U5</a>
<li><a name="NWI-winWidth" href="#NWD0-3">winWidth</a>: <a href="#NW0-2ob9xm-1">U1</a>, <a href="#NWD0-3">D2</a>, <a href="#NWD0-5">U3</a>, <a href="#NW0-1FaN2o-4">U4</a>, <a href="#NWD0-8">U5</a>
<li><a name="NWI-zoomCam" href="#NW0-2f73Kx-1">zoomCam</a>: <a href="#NWD0-6">U1</a>, <a href="#NW0-2f73Kx-1">D2</a>
</ul>
</body></html>

